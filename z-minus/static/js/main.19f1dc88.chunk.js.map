{"version":3,"sources":["core/tile.ts","core/board.ts","ai/actions.ts","ai/randomWalk.ts","core/unit.ts","core/player.ts","App.tsx","core/game.ts","index.tsx"],"names":["Tile","owner","isHome","q","r","s","undefined","coords","mesh","console","error","this","Vector3","scene","radius","pos","generateMesh","x","y","z","meshInst","createInstance","position","copyFrom","isVisible","units","players","unitsOnTile","filter","u","tile","length","requiredCount","Math","max","i","player","_elapsedMillis","elapsedMillis","instancedBuffers","color","homeTileColor","tileColor","conqueror","unit","active","resourceCount","other","equals","a","b","subtract","abs","qf","rf","sf","round","qDist","rDist","sDist","material","StandardMaterial","specularColor","Color3","MeshBuilder","CreateDisc","tessellation","rotation","PI","registerInstancedBuffer","Color4","directions","sqrt3","sqrt","Board","acceptTile","tiles","tileList","R","push","generate","tileToPos","updateDrawn","updateState","roundCoords","map","dir","t","moveTowards","wait","target","targetDirection","normalize","curDirection","clone","Dot","scaleToRef","velocity","subtractToRef","timeMillis","randomWalkAI","randomElem","array","floor","random","board","curTile","posToTile","neighbours","nextNeighbour","warn","homeTile","Unit","id","ai","targetAngle","unitColor","scaleAndAddToRef","deadUnitColor","next","acos","Forward","diameter","height","CreateCylinder","enclose","cost","p1Res","p2Res","fpsRes","gameMsg","Player","name","hue","maxSaturation","find","game","spawnUnit","unitCount","saturation","value","alpha","result","HSVtoRGBToRef","g","Game","allUnits","activeUnits","winner","gaia","player1","player2","isAlive","onSceneReady","ambientColor","camera","ArcRotateCamera","setTarget","Zero","canvas","getEngine","getRenderingCanvas","attachControl","lights","HemisphericLight","intensity","advancedTexture","AdvancedDynamicTexture","CreateFullscreenUI","TextBlock","text","fontSize","textHorizontalAlignment","textVerticalAlignment","addControl","elapsedMillisSinceUpdate","running","onRender","getFps","getDeltaTime","statusDisplayText","App","className","antialias","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.19f1dc88.chunk.js","sourcesContent":["import {\n  Color3,\n  Color4,\n  InstancedMesh,\n  Mesh,\n  MeshBuilder,\n  Scene,\n  StandardMaterial,\n  Vector3,\n} from '@babylonjs/core';\nimport { Player } from './player';\nimport { Unit } from './unit';\n\nconst resourcesPerSecond = 1;\n\nexport class Tile {\n  // using q, r, s cubic coords\n  public readonly coords: Vector3;\n  public mesh: InstancedMesh;\n\n  public constructor(\n    public owner: Player,\n    public readonly isHome: boolean,\n    q: number,\n    r: number,\n    s: number | undefined = undefined\n  ) {\n    if (s === undefined) {\n      s = -(q + r);\n    } else if (q + r + s !== 0) {\n      console.error('Attempting to create an invalid Tile', { q, r, s });\n    }\n\n    this.coords = new Vector3(q, r, s);\n    this.mesh = undefined!; // init'd on generate\n  }\n\n  public generate(scene: Scene, radius: number, pos: Vector3) {\n    if (!Tile.mesh) {\n      Tile.mesh = Tile.generateMesh(scene, radius);\n    }\n\n    const { x, y, z } = this.coords;\n    const meshInst = Tile.mesh.createInstance(`tileMesh/${x}/${y}/${z}`);\n    meshInst.position.copyFrom(pos);\n    meshInst.isVisible = true;\n    this.mesh = meshInst;\n  }\n\n  private conqueror(units: Unit[], players: Player[]): Player | undefined {\n    const unitsOnTile = units.filter((u) => u.tile === this);\n    if (unitsOnTile.length > 0) {\n      const requiredCount = Math.max(2, (unitsOnTile.length * 2) / 3);\n      for (let i = 0; i < players.length; i++) {\n        const player = players[i];\n        const playerUnits = unitsOnTile.filter((u) => u.owner === player);\n        if (playerUnits.length >= requiredCount) {\n          return player;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  public updateDrawn(_elapsedMillis: number) {\n    // nothing needs to be updated per frame\n  }\n\n  public updateState(elapsedMillis: number, units: Unit[], players: Player[]) {\n    this.mesh.instancedBuffers.color = this.isHome\n      ? this.owner.homeTileColor\n      : this.owner.tileColor;\n\n    const conqueror = this.conqueror(units, players);\n    if (conqueror) {\n      this.owner = conqueror;\n      for (let i = 0; i < units.length; i++) {\n        const unit = units[i];\n        if (unit.tile === this && unit.owner !== conqueror) {\n          unit.active = false;\n        }\n      }\n    }\n\n    this.owner.resourceCount += (elapsedMillis * resourcesPerSecond) / 1000;\n  }\n\n  public equals(other: Tile): boolean {\n    return this.coords.equals(other.coords);\n  }\n\n  public static distBetween(a: Tile, b: Tile): number {\n    const { x, y, z } = a.coords.subtract(b.coords);\n    return 0.5 * (Math.abs(x) + Math.abs(y) + Math.abs(z));\n  }\n\n  // increment in CCW order, starting with straight up (north).\n  public static directions = [\n    new Vector3(+0, +1, -1), // north\n    new Vector3(+1, +0, -1), // north east\n    new Vector3(+1, -1, +0), // south east\n    new Vector3(+0, -1, +1), // south\n    new Vector3(-1, +0, +1), // south west\n    new Vector3(-1, +1, +0), // north west\n  ];\n\n  public static roundCoords(qf: number, rf: number): { q: number; r: number } {\n    const sf = -qf - rf;\n    const q = Math.round(qf);\n    const r = Math.round(rf);\n    const s = Math.round(sf);\n\n    const qDist = Math.abs(qf - q);\n    const rDist = Math.abs(rf - r);\n    const sDist = Math.abs(sf - s);\n\n    if (qDist > Math.max(rDist, sDist)) {\n      return { q: -r - s, r };\n    }\n    if (rDist > sDist) {\n      return { q, r: -q - s };\n    }\n    return { q, r };\n  }\n\n  private static mesh: Mesh | undefined;\n  private static generateMesh(scene: Scene, radius: number): Mesh {\n    const material = new StandardMaterial(`tileMeshMaterial`, scene);\n    material.specularColor = new Color3(0.5, 0.6, 0.87);\n\n    const mesh = MeshBuilder.CreateDisc(\n      `tileMesh`,\n      { radius, tessellation: 6 },\n      scene\n    );\n\n    mesh.rotation.x = Math.PI * 0.5; // rotate from XY plane to XZ\n    mesh.material = material;\n    mesh.isVisible = false; // hide prototype, only the instanced copies should be visible\n\n    mesh.registerInstancedBuffer('color', 4);\n    mesh.instancedBuffers.color = new Color4(1, 1, 1, 1);\n\n    return mesh;\n  }\n}\n","import { Scene, Vector3 } from '@babylonjs/core';\nimport { Player } from './player';\nimport { Tile } from './tile';\nimport { Unit } from './unit';\n\nconst sqrt3 = Math.sqrt(3);\n\ntype TileFilter = (q: number, r: number, s: number) => boolean;\n\nconst tileSize = 2;\nconst drawnTileSize = 0.98 * tileSize;\n\nexport class Board {\n  private readonly tiles: Tile[][]; // indexed by q,r\n  public readonly tileList: Tile[]; // just a list\n\n  constructor(\n    private readonly radius: number, // integer, number of tiles from center\n    private readonly players: Player[],\n    acceptTile: TileFilter\n  ) {\n    this.tiles = [];\n    this.tileList = [];\n\n    const R = radius;\n    for (let q = -R; q <= R; q++) {\n      this.tiles[q + R] = [];\n\n      for (let r = -R; r <= R; r++) {\n        const s = -(q + r);\n\n        if (-R <= s && s <= R && acceptTile(q, r, s)) {\n          const isHome = q === 0 && Math.abs(r) === R;\n          const owner = players[isHome ? (r === R ? 1 : 2) : 0];\n          const tile = new Tile(owner, isHome, q, r);\n          this.tiles[q + R][r + R] = tile;\n          this.tileList.push(tile);\n        }\n      }\n    }\n  }\n\n  public generate(scene: Scene) {\n    for (let i = 0; i < this.tileList.length; i++) {\n      const tile = this.tileList[i];\n      tile.generate(scene, drawnTileSize, this.tileToPos(tile));\n    }\n  }\n\n  public updateDrawn(elapsedMillis: number) {\n    for (let i = 0; i < this.tileList.length; i++) {\n      this.tileList[i].updateDrawn(elapsedMillis);\n    }\n  }\n\n  public updateState(elapsedMillis: number, units: Unit[]) {\n    for (let i = 0; i < this.tileList.length; i++) {\n      this.tileList[i].updateState(elapsedMillis, units, this.players);\n    }\n  }\n\n  public tile(q: number, r: number): Tile | undefined {\n    const R = this.radius;\n    if (-R <= q && q <= R && -R <= r && r <= R) {\n      return this.tiles[q + R][r + R];\n    }\n    return undefined;\n  }\n\n  public tileToPos(tile: Tile): Vector3 {\n    // see https://www.redblobgames.com/grids/hexagons/implementation.html#layout\n    const { x, y } = tile.coords;\n    return new Vector3(1.5 * x * tileSize, 0, sqrt3 * (0.5 * x + y) * tileSize);\n  }\n\n  public posToTile(pos: Vector3): Tile | undefined {\n    // see https://www.redblobgames.com/grids/hexagons/implementation.html#layout\n    const x = pos.x / tileSize;\n    const z = pos.z / tileSize;\n    const { q, r } = Tile.roundCoords((2.0 / 3.0) * x, (sqrt3 * z - x) / 3.0);\n    return this.tile(q, r);\n  }\n\n  public neighbours(tile: Tile): Tile[] {\n    const { x, y } = tile.coords;\n    return Tile.directions\n      .map((dir) => this.tile(x + dir.x, y + dir.y))\n      .filter((t) => !!t) as Tile[];\n  }\n}\n","import { Vector3 } from '@babylonjs/core';\nimport { Unit } from '../core';\n\nconst maxSpeed = 1; // units per second\n\nexport function* moveTowards(unit: Unit, target: Vector3) {\n  const targetDirection = target.subtract(unit.position).normalize();\n  let curDirection = targetDirection.clone();\n\n  while (Vector3.Dot(targetDirection, curDirection) > 0) {\n    targetDirection.normalize().scaleToRef(maxSpeed, unit.velocity);\n\n    yield; // wait for next update\n\n    target.subtractToRef(unit.position, curDirection);\n  }\n}\n\nexport function* wait(timeMillis: number) {\n  let elapsedMillis = 0;\n  while (elapsedMillis < timeMillis) {\n    elapsedMillis += yield;\n  }\n}\n","import { Unit, Board } from '../core';\nimport { moveTowards, wait } from './actions';\n\nfunction randomInt(max: number): number {\n  return Math.floor(Math.random() * max);\n}\n\nfunction randomElem<T>(array: T[]): T | undefined {\n  if (array.length > 0) {\n    return array[randomInt(array.length)];\n  }\n  return undefined;\n}\n\nexport function* randomWalkAI(unit: Unit, board: Board) {\n  while (true) {\n    const curTile = board.posToTile(unit.position);\n    const neighbours = curTile && board.neighbours(curTile);\n    const nextNeighbour = neighbours && randomElem(neighbours);\n    if (!nextNeighbour) {\n      console.warn('ran out of neighbours', neighbours?.length || 0);\n    }\n    const target = nextNeighbour || unit.owner.homeTile;\n    yield* moveTowards(unit, board.tileToPos(target));\n    yield* wait(100);\n  }\n}\n","import {\n  Color3,\n  Color4,\n  InstancedMesh,\n  Mesh,\n  MeshBuilder,\n  Scene,\n  StandardMaterial,\n  Vector3,\n} from '@babylonjs/core';\nimport { randomWalkAI } from '../ai/randomWalk';\nimport { Player } from './player';\nimport { Board } from './board';\nimport { Tile } from './tile';\n\nexport class Unit {\n  private mesh: InstancedMesh;\n  private ai: Generator | undefined;\n  public active: boolean;\n  public velocity: Vector3;\n  private targetAngle: number;\n\n  constructor(\n    public readonly id: number,\n    public readonly owner: Player,\n    public tile: Tile,\n    public position: Vector3\n  ) {\n    this.active = true;\n    this.velocity = new Vector3();\n    this.targetAngle = 0;\n\n    // init'd on generate\n    this.mesh = undefined!;\n    this.ai = undefined!;\n  }\n\n  public generate(scene: Scene, board: Board) {\n    if (!Unit.mesh) {\n      Unit.mesh = Unit.generateMesh(scene, 0.75, 0.1);\n    }\n\n    const meshInst = Unit.mesh.createInstance(`unitMesh/${this.id}`);\n    meshInst.isVisible = true;\n    meshInst.instancedBuffers.color = this.owner.unitColor;\n    meshInst.position.copyFrom(this.position);\n    this.mesh = meshInst;\n\n    this.ai = randomWalkAI(this, board);\n  }\n\n  public updateDrawn(elapsedMillis: number) {\n    if (!this.active) {\n      return;\n    }\n\n    this.velocity.scaleAndAddToRef(elapsedMillis / 1000, this.position);\n    this.mesh.position.copyFrom(this.position); // TODO SM interpolate instead of immediate movement\n    this.mesh.position.y = 0.05 + this.owner.id * 0.01; // TODO SM just a hack to avoid z-buffer issues\n\n    this.mesh.rotation.y = this.mesh.rotation.y * 0.9 + this.targetAngle * 0.1;\n  }\n\n  public updateState(elapsedMillis: number, board: Board) {\n    if (!this.active) {\n      this.mesh.instancedBuffers.color = this.owner.deadUnitColor;\n      this.mesh.position.y -= 0.05; // TODO SM just a hack to avoid z-buffer issues\n      this.ai = undefined;\n      return;\n    }\n\n    this.ai!.next(elapsedMillis);\n    this.tile = board.posToTile(this.position) || this.owner.homeTile;\n    this.targetAngle =\n      Math.PI / 6 +\n      Math.acos(\n        Vector3.Dot(Vector3.Forward(), this.velocity) / this.velocity.length()\n      );\n  }\n\n  private static mesh: Mesh | undefined;\n  private static generateMesh(\n    scene: Scene,\n    diameter: number,\n    height: number\n  ): Mesh {\n    const material = new StandardMaterial(`unitMeshMaterial`, scene);\n    material.specularColor = new Color3(0.8, 0.8, 0.9);\n\n    const mesh = MeshBuilder.CreateCylinder(\n      `unitMesh`,\n      { diameter, height, tessellation: 3, enclose: true },\n      scene\n    );\n\n    mesh.material = material;\n    mesh.isVisible = false; // hide prototype, only instanced meshes are shown\n\n    mesh.registerInstancedBuffer('color', 4);\n    mesh.instancedBuffers.color = new Color4(1, 1, 1, 1);\n\n    return mesh;\n  }\n\n  public static cost = 10;\n}\n","import { Color3, Color4, Scene } from '@babylonjs/core';\nimport { Tile } from './tile';\nimport { Board } from './board';\nimport { Unit } from './unit';\nimport { Game } from './game';\n\nexport class Player {\n  public homeTile: Tile;\n  public tileColor: Color4;\n  public homeTileColor: Color4;\n  public unitColor: Color4;\n  public deadUnitColor: Color4;\n\n  public resourceCount: number;\n\n  constructor(\n    public readonly id: number,\n    public readonly name: string,\n    hue: number,\n    maxSaturation: number\n  ) {\n    this.tileColor = Player.color(hue, 0.4 * maxSaturation, 0.8);\n    this.homeTileColor = Player.color(hue, 0.7 * maxSaturation, 0.6);\n    this.unitColor = Player.color(hue, 0.9 * maxSaturation, 0.95);\n    this.deadUnitColor = Player.color(hue, 0.4 * maxSaturation, 0.3, 0.3);\n\n    this.resourceCount = 0;\n    this.homeTile = undefined!; // init'd on generate\n  }\n\n  public generate(scene: Scene, board: Board) {\n    this.homeTile = board.tileList.find((t) => t.owner === this && t.isHome)!;\n  }\n\n  public updateState(elapsedMillis: number, game: Game) {\n    // automatically spawn unit when there are enough resources\n    if (this.resourceCount > Unit.cost) {\n      this.resourceCount -= Unit.cost;\n      game.spawnUnit(this, this.homeTile);\n    }\n  }\n\n  public isAlive(): boolean {\n    return this.homeTile.owner === this;\n  }\n\n  public statusDisplayText(units: Unit[]): string {\n    const unitCount = units.filter((u) => u.owner === this).length;\n    return `${this.name}: $${Math.floor(\n      this.resourceCount\n    )}, ${unitCount} unit(s)`;\n  }\n\n  private static color(\n    hue: number,\n    saturation: number,\n    value: number,\n    alpha: number = 1\n  ): Color4 {\n    const result = new Color3();\n    Color3.HSVtoRGBToRef(hue, saturation, value, result);\n\n    const { r, g, b } = result;\n    return new Color4(r, g, b, alpha);\n  }\n}\n","import React from 'react';\nimport {\n  Vector3,\n  HemisphericLight,\n  Scene,\n  ArcRotateCamera,\n  Color3,\n} from '@babylonjs/core';\nimport SceneComponent from 'babylonjs-hook';\nimport './App.css';\nimport { Game } from './core';\nimport { AdvancedDynamicTexture, TextBlock } from '@babylonjs/gui';\n\nconst game = new Game();\n\nlet p1Res: TextBlock | undefined;\nlet p2Res: TextBlock | undefined;\nlet fpsRes: TextBlock | undefined;\nlet gameMsg: TextBlock | undefined;\n\nconst onSceneReady = (scene: Scene) => {\n  scene.ambientColor = new Color3(1, 1, 1);\n\n  const camera = new ArcRotateCamera(\n    'camera1',\n    0,\n    0,\n    10,\n    new Vector3(0, 6, 16),\n    scene\n  );\n  camera.setTarget(Vector3.Zero());\n\n  const canvas = scene.getEngine().getRenderingCanvas()!;\n  camera.attachControl(canvas, true);\n\n  const lights = [\n    new HemisphericLight('light', new Vector3(0, 1, -2), scene),\n    new HemisphericLight('light', new Vector3(1, 1, 1), scene),\n    new HemisphericLight('light', new Vector3(-1, 1, 1), scene),\n  ];\n  for (let i = 0; i < lights.length; i++) {\n    lights[i].intensity = 0.375;\n  }\n\n  game.generate(scene);\n  game.spawnUnit(game.players[1], game.board.tile(0, 2)!);\n  game.spawnUnit(game.players[2], game.board.tile(0, -2)!);\n\n  // GUI\n  const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI('UI');\n  p1Res = new TextBlock();\n  p1Res.text = 'Player1: $0';\n  p1Res.color = 'white';\n  p1Res.fontSize = 24;\n  p1Res.textHorizontalAlignment = 0;\n  p1Res.textVerticalAlignment = 1;\n\n  p2Res = new TextBlock();\n  p2Res.text = 'Player2: $0';\n  p2Res.color = 'white';\n  p2Res.fontSize = 24;\n  p2Res.textHorizontalAlignment = 1;\n  p2Res.textVerticalAlignment = 1;\n\n  fpsRes = new TextBlock();\n  fpsRes.text = 'FPS: 0';\n  fpsRes.color = 'white';\n  fpsRes.fontSize = 24;\n  fpsRes.textHorizontalAlignment = 1;\n  fpsRes.textVerticalAlignment = 0;\n\n  gameMsg = new TextBlock();\n  gameMsg.text = '';\n  gameMsg.color = 'white';\n  gameMsg.fontSize = 72;\n  gameMsg.textHorizontalAlignment = 2;\n  gameMsg.textVerticalAlignment = 2;\n\n  advancedTexture.addControl(p1Res);\n  advancedTexture.addControl(p2Res);\n  advancedTexture.addControl(fpsRes);\n  advancedTexture.addControl(gameMsg);\n};\n\nlet elapsedMillisSinceUpdate: number = 0;\nlet running = true;\nconst onRender = (scene: Scene) => {\n  if (fpsRes) {\n    fpsRes.text = `FPS: ${Math.round(scene.getEngine().getFps())}`;\n  }\n  if (!running) {\n    return;\n  }\n\n  const elapsedMillis = scene.getEngine().getDeltaTime();\n  game.updateDrawn(elapsedMillis);\n\n  elapsedMillisSinceUpdate += elapsedMillis;\n  if (elapsedMillisSinceUpdate > 100) {\n    game.updateState(elapsedMillisSinceUpdate);\n    elapsedMillisSinceUpdate = 0;\n\n    if (!game.running()) {\n      running = false;\n      game.updateState(0);\n      if (gameMsg) {\n        gameMsg.text = `${game.winner?.name} wins!`;\n      }\n    }\n  }\n\n  if (p1Res) {\n    p1Res.text = game.players[1].statusDisplayText(game.activeUnits);\n  }\n  if (p2Res) {\n    p2Res.text = game.players[2].statusDisplayText(game.activeUnits);\n  }\n};\n\nfunction App() {\n  return (\n    <div className=\"fullscreen\">\n      <SceneComponent\n        antialias\n        onSceneReady={onSceneReady}\n        onRender={onRender}\n        id=\"game-canvas\"\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import { Scene } from '@babylonjs/core';\nimport { Player } from './player';\nimport { Board } from './board';\nimport { Unit } from './unit';\nimport { Tile } from './tile';\n\nexport class Game {\n  public readonly players: Player[];\n  public readonly board: Board;\n  public readonly allUnits: Unit[];\n  public activeUnits: Unit[];\n  private scene: Scene | undefined;\n  public winner: Player | undefined;\n\n  constructor() {\n    const gaia = new Player(0, 'Gaia', 180, 0.01);\n    const player1 = new Player(1, 'Green', 120, 1);\n    const player2 = new Player(2, 'Red', 0, 1);\n    this.players = [gaia, player1, player2];\n\n    this.board = new Board(2, this.players, () => true);\n    this.allUnits = [];\n    this.activeUnits = [];\n    this.scene = undefined;\n    this.winner = undefined;\n  }\n\n  public generate(scene: Scene) {\n    this.board.generate(scene);\n    for (let i = 0; i < this.activeUnits.length; i++) {\n      this.activeUnits[i].generate(scene, this.board);\n    }\n\n    for (let i = 0; i < this.players.length; i++) {\n      const player = this.players[i];\n      player.generate(scene, this.board);\n    }\n\n    this.scene = scene;\n  }\n\n  public spawnUnit(owner: Player, tile: Tile) {\n    const pos = this.board.tileToPos(tile);\n    const unit = new Unit(this.allUnits.length, owner, tile, pos);\n    this.scene && unit.generate(this.scene, this.board);\n    this.allUnits.push(unit);\n    this.activeUnits.push(unit);\n  }\n\n  public updateDrawn(elapsedMillis: number) {\n    if (!this.scene) return;\n\n    this.board.updateDrawn(elapsedMillis);\n    for (let i = 0; i < this.activeUnits.length; i++) {\n      this.activeUnits[i].updateDrawn(elapsedMillis);\n    }\n  }\n\n  public updateState(elapsedMillis: number) {\n    this.board.updateState(elapsedMillis, this.activeUnits);\n    for (let i = 0; i < this.activeUnits.length; i++) {\n      this.activeUnits[i].updateState(elapsedMillis, this.board);\n    }\n\n    this.activeUnits = this.allUnits.filter((u) => u.active);\n\n    for (let i = 1; i <= 2; i++) {\n      const player = this.players[i];\n      player.updateState(elapsedMillis, this);\n      if (!player.isAlive()) {\n        this.winner = this.players[3 - i]; // the other player wins\n      }\n    }\n  }\n\n  public running(): boolean {\n    return this.winner === undefined;\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}